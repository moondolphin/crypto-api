// Code generated by MockGen. DO NOT EDIT.
// Source: coin_port.go
//
// Generated by this command:
//
//	mockgen -source=coin_port.go -destination=../test/mocks/coin_port_mock.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	domain "github.com/moondolphin/crypto-api/domain"
	gomock "go.uber.org/mock/gomock"
)

// MockCoinRepository is a mock of CoinRepository interface.
type MockCoinRepository struct {
	ctrl     *gomock.Controller
	recorder *MockCoinRepositoryMockRecorder
	isgomock struct{}
}

// MockCoinRepositoryMockRecorder is the mock recorder for MockCoinRepository.
type MockCoinRepositoryMockRecorder struct {
	mock *MockCoinRepository
}

// NewMockCoinRepository creates a new mock instance.
func NewMockCoinRepository(ctrl *gomock.Controller) *MockCoinRepository {
	mock := &MockCoinRepository{ctrl: ctrl}
	mock.recorder = &MockCoinRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCoinRepository) EXPECT() *MockCoinRepositoryMockRecorder {
	return m.recorder
}

// GetBySymbol mocks base method.
func (m *MockCoinRepository) GetBySymbol(ctx context.Context, symbol string) (*domain.Coin, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBySymbol", ctx, symbol)
	ret0, _ := ret[0].(*domain.Coin)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBySymbol indicates an expected call of GetBySymbol.
func (mr *MockCoinRepositoryMockRecorder) GetBySymbol(ctx, symbol any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBySymbol", reflect.TypeOf((*MockCoinRepository)(nil).GetBySymbol), ctx, symbol)
}

// GetEnabledBySymbol mocks base method.
func (m *MockCoinRepository) GetEnabledBySymbol(ctx context.Context, symbol string) (*domain.Coin, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetEnabledBySymbol", ctx, symbol)
	ret0, _ := ret[0].(*domain.Coin)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetEnabledBySymbol indicates an expected call of GetEnabledBySymbol.
func (mr *MockCoinRepositoryMockRecorder) GetEnabledBySymbol(ctx, symbol any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEnabledBySymbol", reflect.TypeOf((*MockCoinRepository)(nil).GetEnabledBySymbol), ctx, symbol)
}

// ListEnabled mocks base method.
func (m *MockCoinRepository) ListEnabled(ctx context.Context) ([]domain.Coin, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListEnabled", ctx)
	ret0, _ := ret[0].([]domain.Coin)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListEnabled indicates an expected call of ListEnabled.
func (mr *MockCoinRepositoryMockRecorder) ListEnabled(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListEnabled", reflect.TypeOf((*MockCoinRepository)(nil).ListEnabled), ctx)
}

// Upsert mocks base method.
func (m *MockCoinRepository) Upsert(ctx context.Context, c domain.Coin) (*domain.Coin, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Upsert", ctx, c)
	ret0, _ := ret[0].(*domain.Coin)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Upsert indicates an expected call of Upsert.
func (mr *MockCoinRepositoryMockRecorder) Upsert(ctx, c any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upsert", reflect.TypeOf((*MockCoinRepository)(nil).Upsert), ctx, c)
}
